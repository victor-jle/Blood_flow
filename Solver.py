import numpy as np 
import pandas as pd 
from scipy.interpolate import interp1d
import matplotlib.pyplot as plt
from matplotlib import cm
from math import ceil 
from tqdm import tqdm
import bisect

from os import makedirs
from os.path import exists

import sys

''' 
Python Script Implementation of the 2-step Lax-Wendroff scheme for solving the 1D NSE in one blood vessel with 3WK boundary conditions
Parameters are being declared in the main program, except for the inlet data which is being read from a csv file in the get_data function.
The csv file should contain two columns, the first one being the time values and the second one being the flow rate values at the inlet of the 
vessel in centimeters cubed per second.

In there isn't any csv file in argument, the function based on a three wave component model will simulate the blood flow at the inlet of the artery

Data example_inlet.csv available from the simulations ran by Kolachalama V, Bressloff NW, Nair PB and Shearman CP (2007) 
Predictive Haemodynamics in a One-Dimensional Carotid Artery Bifurcation. 
Part I: Application to Stent Design. IEEE Transactions on Biomedical Engineering 54 (5): 802-812, doi 10.1109/TBME.2006.889188

TO DO : 
	- Priority : Check dB/dr dr/dz term 
    - Update pressure boundary condition
	- Dispatch function in multiples scripts for readability
'''

def CFL_condition(u, a0, alpha, rho, dx, dt, n, nt):
	"""
	Allows us to check if the CFL condition is satisfied
	
	Parameters :
	- u : float, average velocity at a given time step
	- a0 : float, cross sectional area at rest
	- alpha : float, elatance coefficient
	- rho : float, blood density 
	- dx : float, space step
	- dt : float, time step
	- n : int current time step
	- nt : total number of time steps

	Returns :
	- No returned values if CFL respected (True), raise ValueError if not respected (False)
	"""
	
	if (u + np.sqrt(alpha*a0/rho))*(dt/dx) <= 1:
		if n == 1:
			print("Wave speed [cm/s] : " + str(round(np.sqrt(alpha*a0/rho), 2)))
		if (n == nt-1):
			print("CFL Condition was satisfied for every time steps")
		else:
			pass
	else:
		raise ValueError("The CFL condition isn't satisfied, the time step needs to be lower")

def Three_wave_component(t):
	"""
	Creates an inflow function obtained as a sum of simulated percussion, tidal and dicrotic  wave
	components, with a heart rate of 80 beats per minutes 

	From :  Takumi Nagasawa et al. « Blood Pressure Estimation by Photoplethysmogram
	Decomposition into Hyperbolic Secant Waves ». In : Applied Sciences 12.4 (2022).
	issn : 2076-3417. doi : 10.3390/app12041798.

	Parameters :
	- t : float or array corresponding to the time in seconds

	Returns :
	- Q(t) : float or array corresponding to the blood flow at the inlet for the time t
	"""
	Q0 = 3.0;                  		# Peak flow rate (cm^3/s)

	relative_pulse_amplitude = 1;   # Relative pulse scaling
	#n_cycles = 2;                  # Number of heart cycles
	heart_rate = 75;                # Heart rate in beats per minute (bpm)
	T = 60 / heart_rate;      		# Heartbeat period (seconds)

	# Three-phase pulse parameters (user-defined as fractions of the heart cycle)
	amp_phase1 = 0.25 * Q0;         # Amplitude of phase 1 (systolic peak)
	amp_phase2 = 0.115 * Q0;        # Amplitude of phase 2 (diastolic trough)
	amp_phase3 = 0.05 * Q0;         # Amplitude of phase 3 (resting phase)

	t_phase1 = 0.30 * T;        
	t_phase2 = 0.62 * T;       
	t_phase3 = 0.75 * T;       

	len_phase1 = 0.48 * T;     
	len_phase2 = 0.3 * T;      
	len_phase3 = 0.3 * T;      

	return Q0 + relative_pulse_amplitude*((amp_phase1 * np.exp(-((t - t_phase1)**2) / (2 * (len_phase1 / 3)**2))) \
		+ (amp_phase2 * np.exp(-((t - t_phase2)**2) / (2 * (len_phase2 / 3)**2))) \
			+ (amp_phase3 * np.exp(-((t - t_phase3)**2) / (2 * (len_phase3 / 3)**2))))

def get_data(arg):
	"""
	Returns the inlet flow rate at time t (either float or array)

	Parameters : 
	- argument passed when calling the python script

	Returns :
	- f : Function interpolating flow rate from the csv file [cm3/s]
	- T : float representing the period length [s]
	"""

	if len(arg) == 1:
		return 60/75, Three_wave_component
	else:
		path = str(arg[1])
		data = pd.read_csv(path, header=None)
		t_data = data[0].values
		y_data = data[1].values
		f = interp1d(t_data, y_data, kind='linear')
		T = t_data[-1]
	return T, f

def write_data(A, P, Q, x, t):
	"""
	Function allowing us to export the data generated by the simulation into csv file

	Parameters :
	- A : data for the cross-sectional area [cm²]
	- P : data for the transmural pressure  [mmHg]
	- Q : data for the blood flow 			[m^3/s]
	- x : spatial points for the data (either array or float)
	- t : time points for the data (either array or float)

	Returns :
	- This function doesn't do any return in the program, it will create a data folder if non-existant with five csv file in it (one for each parameters)
	"""
	if not exists("data/"):
		makedirs("data/")
	np.savetxt("data/area.csv", A[:,:], delimiter=',')
	np.savetxt("data/pressure1.csv", P[:,:], delimiter=',')
	np.savetxt("data/flow.csv", Q[:,:], delimiter=',')
	np.savetxt("data/xpoint1.csv", x[:], delimiter=',')
	np.savetxt("data/tpoint1.csv", t[:], delimiter=',')

def periodic(t, T):
	"""
	Returns equivalent time of the first period

	Parameters :
	- t : float representing the current time
	- T : float representing the period length

	Returns :
	- t % T : float representing the equivalent time in the first period
	"""
	return t % T

def inlet_bc(Q_inlet, n, A, Q, dx, dt, mu, rho, alpha, dalphadr, T, drdz):
	"""
	Applies the inlet boundary condition for the vessel.
	doi 10.1109/TBME.2006.889188 | doi 10.1114/1.1326031

	Parameters :
	- Q_inlet : interpolated function of the flow rate at the inlet of the vessel
	- n : integer representing the current time step 
	- A : array containing the cross-sectional area at each spatial point
	- Q : array containing the flow rate at each spatial point
	- dx : float representing the spatial step 
	- dt : float representing the time step
	- mu : float representing the blood viscosity
	- rho : float representing the blood density
	- alpha : array representing the elastance coefficient
	- dalphadr : array with dalpha/dr
	- T : float representing the period length
	- drdz : array containing the values for dr/dz

	Returns :
	- a_inlet : float corresponding to the cross-sectional area at the inlet of the vessel
	- q_inlet : float corresponding to the flow rate at the inlet of the vessel

	"""
	time = n*dt
	q_inlet = Q_inlet(periodic(time,T)) # q^{n+1}_0
	q_nph_0 = Q_inlet(periodic(time-(dt/2),T)) # q^{n+1/2}_0
	q_np_half = 0.5*(Q[1] + Q[0]) - 0.5 * (dt/dx) * (Flux(Q,A,A0,alpha, rho, j = 1, k = 2) - Flux(Q,A,A0,alpha,rho,j = 0, k = 1))\
			  + dt/2 * (Source(Q,A,A0, mu,rho, drdz,alpha,dalphadr, j = 1, k = 2) + Source(Q,A,A0,mu,rho,drdz,alpha,dalphadr, j = 0, k = 1)) # q^{n+1/2}_{1/2}
	q_m_half = 2*q_nph_0 - q_np_half # q^{n+1/2}_{-1/2}
	a_inlet = A[0] - (dt/dx) * (q_np_half - q_m_half) # A^{n+1}_0
	return a_inlet[0], q_inlet

def WK_outlet_bc(R1, R2, C, Q, A, A0, dx, dt, mu, rho, alpha, dalphadr, diastolic_pressure, drdz, drdzhp, drdzhm):
	"""
	Computes the outlet boundary condition basing on the three element windkessel (3WK) model by using the fixed point iteration method.
	doi 10.1109/TBME.2006.889188 | doi 10.1114/1.1326031
	Parameters : 
	- R1, R2 : floats corresponding to two resistances [g/s * cm^{-4}]
	- C : float , compliance coefficient [cm^4.s^2/g]
	- Q : array containing the flow rate at each spatial point
	- A : array containing the cross-sectional area at each spatial point
	- A0 : float representing the cross-sectional area at rest
	- dx : float representing the spatial step
	- dt : float representing the time step
	- mu : float representing the blood viscosity 
	- rho : float representing the blood density
	- alpha : elastance coefficient
	- dalphadr
	- diastolic_pressure : float representing average diastolic pressure
	- drdz : array containing the values for dr/dz
	- drdzhp
	- drdzhm

	Returns :
	- a_outlet : float corresponding to the cross-sectional area at the outlet of the vessel
	- q_outlet : float corresponding to the flow rate at the outlet of the vessel
	"""
	q_n = Q[-1] 
	a_n = A[-1]
	p_m_p1 = p_n = alpha[-1]*(a_n - A0[-1]) + diastolic_pressure*1333.22# Initial guess for pressure at outlet (same as before, i.e p^{n+1}_M = p^n_M)

	A_np_mp = 0.5 * (A[-1] + A[-2]) - 0.5 * (dt/dx) * (Q[-1] - Q[-2])
	A_np_mm = 0.5 * (A[-2] + A[-3]) - 0.5 * (dt/dx) * (Q[-2] - Q[-3])

	Q_np_mp = (0.5 * (Q[-1] + Q[-2]) - 0.5 * (dt/dx) * (Flux(Q,A,A0,alpha, rho, j = -1) - Flux(Q,A,A0,alpha, rho, j = -2, k = -1))\
			+ (dt/2) * (Source(Q,A,A0,mu,rho,drdz,alpha,dalphadr, j = -1) + Source(Q,A,A0,mu,rho,drdz,alpha,dalphadr, j = -2, k = -1)))
	
	Q_np_mm = (0.5 * (Q[-2] + Q[-3]) - 0.5 * (dt/dx) * (Flux(Q,A,A0,alpha, rho, j = -2, k = -1) - Flux(Q,A,A0,alpha, rho, j = -3, k = -2))\
			+ (dt/2) * (Source(Q,A,A0,mu,rho,drdz,alpha,dalphadr, j = -2, k = -1) + Source(Q,A,A0,mu,rho,drdz,alpha,dalphadr, j = -3, k = -2)))
	
	Q_mm = Q[-2] - dt/dx * (Q_np_mp**2/A_np_mp + alpha/(2*rho) * (A_np_mp**2 - A0[-2]**2) - Q_np_mm**2/A_np_mm - alpha[-2]/(2*rho) * (A_np_mm**2 - A0[-2]**2))\
		 - (dt/2) * ((8*np.pi*mu)/(rho) * (Q_np_mp/A_np_mp + Q_np_mm/A_np_mm) - (1/(2*rho))*((A_np_mp**2 - A0[-2]**2)*dalpha_half_p[-2] - 4*((np.pi)**2) * (np.sqrt(A0[-2]/np.pi))**3 * alpha_half_p[-2])*drdzhp[-2]\
	    - (1/(2*rho))*((A_np_mm**2 - A0[-2]**2)*dalpha_half_m[-2] - 4*((np.pi)**2) * (np.sqrt(A0[-2]/np.pi))**3 * alpha_half_m[-2])*drdzhm[-2])

	k = 0
	while k < 1000:
		p_old = p_m_p1
		q_outlet = ((p_old - p_n)/R1) + q_n + (dt*p_n)/(R1*C*R2) - (q_n*(R1+R2)*dt)/(C*R1*R2)
		a_outlet = a_n - (dt/dx)*(q_outlet - Q_mm[0])
		p_m_p1 = alpha[-1]*(a_outlet - A0[-1]) + diastolic_pressure*1333.22
		if abs(p_m_p1 - p_old) < 1e-7:
			break
		k +=1
	return a_outlet, q_outlet
 
def pressure_outlet(P, A, A0, Q, alpha, rho, mu, dx, dt):
	"""
	Computes the flow and area at the outlet of the domain given a pressure boundary condition

	Parameters :
	- P : function of the pressure given at the outlet of the vessel
	- A : array cross sectional area of the vessel
	- A0 : float cross sectional area of the vessel at rest
	- Q : array corresponding to the flow 
	- alpha : float elastance coefficient
	- rho : float for the blood density
	- mu : float for the blood viscosity
	- dx : space step 
	- dt : time step

	Returns : 
	- a_out : value of the cross sectional area at the outlet
	- q_out : value of the blood flow at the outlet of the vessel
	"""

	a_n = A[-1]
	q_n = Q[-1]
	a_out = (P/alpha) + A0[-1]
	a_np_mm = 0.5*(A[-1] + A[-2]) - dt/(2*dx) *(Q[-1] - Q[-2])
	q_np_mm = 0.5 * (Q[-1] + Q[-2]) - 0.5 * (dt/dx) * (Flux(Q, A, A0, alpha, rho, j = -1) - Flux(Q, A, A0, alpha, rho, j = -1, k = -2)) \
				+ (dt/2) * (Source(Q, A, mu, rho, j = -1) + Source(Q, A, mu, rho, j = -2, k = -1)) # q^{n+1/2}_{N-1/2}
	
	a_np_mp = 2*a_out - a_np_mm
	q_np_mp = (a_n - a_out)*(dx/dt) + q_np_mm

	rhp = np.sqrt(A0_half_p[-1]/np.pi)
	rhm = np.sqrt(A0_half_m[-1]/np.pi)
	
	q_out = q_n - (dt/dx) * (q_np_mp**2/a_np_mp + (alpha_half_p[-1]/(2*rho)) * (a_np_mp - A0_half_p[-1]) - (q_np_mm**2/a_np_mm + (alpha_half_m[-1]/(2*rho)) * (a_np_mm - A0_half_m[-1]))) + (dt/2) * \
	(-(8*np.pi*mu)/(rho)*(q_np_mp/a_np_mp)- (1/(2*rho))*((a_np_mp**2 - A0_half_p[-1]**2)*dalpha_half_p[-1] - 4*((np.pi)**2) * (rhp**3) * alpha_half_p[-1])*drdz_half_p[-1] \
	-(8*np.pi*mu)/(rho)*(q_np_mm/a_np_mm) - (1/(2*rho))*((a_np_mm**2 - A0_half_m[-1]**2)*dalpha_half_m[-1] - 4*((np.pi)**2) * (rhm**3) * alpha_half_m[-1])*drdz_half_m[-1])
	
	return a_out, q_out	

def pressure_inlet(P, A, A0, Q, alpha, rho, mu, dx, dt):
	"""
	Computes the flow and cross sectional area at the inlet of the vessel, given a pressure in Pa 

	Parameters :
	- P : function of pressure at the inlet of the vessel for each time step
	- A : array cross sectional area of the vessel
	- A0 : float cross sectional area of the vessel at rest
	- Q : array corresponding to the flow 
	- alpha : float elastance coefficient
	- rho : float for the blood density
	- mu : float for the blood viscosity
	- dx : space step 
	- dt : time step

	Returns : 
	- a_in : value of the cross sectional area at the inlet
	- q_in : value of the blood flow at the inlet of the vessel
	"""
	a_0 = A[0]
	q_0 = Q[0]
	a_in = ((P/alpha))+A0[0]

	a_np_mp = 0.5*(A[0] + A[1]) - dt/(2*dx) * (Q[1] - Q[0])
	q_np_mp = 0.5*(Q[1] + Q[0]) - 0.5 * (dt/dx) * (Flux(Q,A,A0,alpha, rho, j = 1, k = 2) - Flux(Q,A,A0,alpha,rho,j = 0, k = 1))\
			  + dt/2 * (Source(Q,A,A0, mu,rho, drdz,alpha,dalphadr, j = 1, k = 2) + Source(Q,A,A0,mu,rho,drdz,alpha,dalphadr, j = 0, k = 1)) # q^{n+1/2}_{1/2}
	
	a_np_mm = 2*a_0 - a_np_mp
	q_np_mm = q_np_mp + (dx/dt) * (a_in - a_0)

	rhp = np.sqrt(A0_half_p[0]/np.pi)
	rhm = np.sqrt(A0_half_m[0]/np.pi)

	q_in = q_0 - (dt/dx) * (q_np_mp**2/a_np_mp + (alpha_half_p[0]/(2*rho)) * (a_np_mp - A0_half_p[0]) - (q_np_mm**2/a_np_mm + (alpha_half_m[0]/(2*rho)) * (a_np_mm - A0_half_m[0]))) + (dt/2) * \
	(-(8*np.pi*mu)/(rho)*(q_np_mp/a_np_mp)- (1/(2*rho))*((a_np_mp**2 - A0_half_p[0]**2)*dalpha_half_p[0] - 4*((np.pi)**2) * (rhp**3) * alpha_half_p[0])*drdz_half_p[0] \
	-(8*np.pi*mu)/(rho)*(q_np_mm/a_np_mm) - (1/(2*rho))*((a_np_mm**2 - A0_half_m[0]**2)*dalpha_half_m[0] - 4*((np.pi)**2) * (rhm**3) * alpha_half_m[0])*drdz_half_m[0])
	
	return a_in, q_in

def HicksHenneBump(x, x_anomaly, x_width, a, r0, stenosis, aneurysm):
	"""
	Returns the cross-sectional area of the vessel with a bump [needs update to generate a function which is C1]

	Parameters :
	- x : float representing the spatial point (for convenience we normalize to get [0,1])
	- x_anomaly : float representing the location of the maximum point of the bump (in [0,1])
	- x_width : float representing the width of the bump (in [0,L])
	- a : float representing the amplitude of the bump (in [0,r0])
	- r0 : float representing the initial radius of the vessel

	Returns :
	- r : float representing the radius at the spatial point x
	"""
	if stenosis:
		r = r0 - a*(np.sin(np.pi*x**(np.log(0.5)/np.log(x_anomaly)))**(x_width))
	elif aneurysm:
		r = r0 + a*(np.sin(np.pi*x**(np.log(0.5)/np.log(x_anomaly)))**(x_width))
	else:
		r = r0*np.ones_like(x)
	return r

def drdx(x, stenosis, aneurysm, x_anomaly, x_width, a, x_start, x_end):
	"""
	Placeholder but will be used to compute dr0/dz used for the source term,

	Parameters :
	- x : array containing Discretized artery
	- stenosis, aneurysm : boolean representing if the vessel has an anomaly or not
	- x_anomaly : float representing the location of the maximum point of the bump (in [0,1])
	- x_width : float representing the width of the bump (in [0,L])
	- a : float representing the amplitude of the bump (in [0,r0])
	- x_start : beginning of the anomaly 
	- x_end : end of the anomaly

	Returns :
	- dr : array corresponding to the exact computed value of dr/dz
	"""
	if stenosis or aneurysm:
		index_min = bisect.bisect_left(x, x_start)
		index_max = bisect.bisect_left(x, x_end)

		y = np.linspace(0, 1, index_max-index_min +1)
		exponent = np.log(0.5) / np.log(x_anomaly)
		sin_arg = np.pi * y**exponent
		dr_anomaly = (-np.log(2) * np.pi * a * y**(-1 + exponent) * x_width * np.cos(sin_arg) * (np.sin(sin_arg) ** (x_width - 1)) / np.log(x_anomaly))
		#dr_anomaly = a*(np.pi**x_width)*powx*(y**(powx-1))*np.cos((np.pi**x_width)*(y**powx))
		
		dr = np.zeros_like(x)
		dr[index_min:index_max+1] = dr_anomaly
		if aneurysm:
			return dr
		else:
			return -dr
	else:
		return np.zeros_like(x)

def Flux(Q, A, A0, alpha, rho, **kwargs):
	"""
	Computes the flux term used during the discretisation

	Parameters : 
	- Q : array containing the flow rate at each spatial point
	- A : array containing the cross-sectional area at each spatial point
	- A0 : array representing the cross-sectional area at rest at each spatial point
	- alpha : float for the elastance coefficient
	- rho : float for the blood density

	- Keywords arguments :
		- j : index variable = start (mandatory)
		- k : index variable = end (leave blank if until last coef)
	"""
	if 'j' in kwargs:
		j = kwargs['j']
		q = Q[j:]
		a = A[j:]
		a0 = A0[j:]
		al = alpha[j:]
	if 'k' in kwargs:
		k = kwargs['k']
		q = Q[j:k]
		a = A[j:k]
		a0 = A0[j:k]
		al = alpha[j:k]
	if 'j' not in kwargs and 'k' not in kwargs:
		raise IndexError("At least the start index 'j' must be specified")
	res = np.pow(q,2)/a + (al/(2*rho))*(np.pow(a,2)-np.pow(a0,2))
	return res

def Source(Q, A, A0, mu, rho, dr, alpha, dalphadr, **kwargs):
	"""
	Computes the source term used during the discretisation

	Parameters : 
	- Q : array containing the flow rate at each spatial point
	- A : array containing the cross-sectional area at each spatial point
	- A0 : array containing the cross-sectional area at rest at each spatial point
	- mu : float for the blood viscosity
	- rho : float for the blood density
	- alpha : array for the elastance coefficient
	- dalphadr : array for ∂alpha/∂r
	- dr : array containing the values of ∂r/∂z

	- Keywords arguments :
		- j : index variable = start (mandatory)
		- k : index variable = end (leave blank if until last coef)
	"""
	if 'j' in kwargs:
		j = kwargs['j']
		q = Q[j:]
		a = A[j:]
		a0 = A0[j:]
		drdz = dr[j:]
		al = alpha[j:]
		dal = dalphadr[j:]
	if 'k' in kwargs:
		k = kwargs['k']
		q = Q[j:k]
		a = A[j:k]
		a0 = A0[j:k]
		drdz = dr[j:k]
		al = alpha[j:k]
		dal = dalphadr[j:k]
	if 'j' not in kwargs and 'k' not in kwargs:
		raise IndexError("At least the start index 'j' must be specified")
	r0 = np.sqrt(a0/np.pi)
	res = -(8*np.pi*mu)/(rho)*(q/a)\
		  - (1/(2*rho))*((a**2 - a0**2)*dal - 4*((np.pi)**2) * (r0**3) * al)*drdz
	return res

def gaussian_aneurysm(x, A, mu, sigma):
    """
    Function that return the radius of a vessel concerned by an aneurism at each point of the discretization.
    Contrary to HicksHenneBump function, this function is C1.
    
    Parameters :
    - x: float/array : spatial points
    - A: float corresponding to the normalizing constant (= amplitude of the bump)
    - mu: location of the amplitude (in [0,L])
    - sigma: Standard deviation  (in ]0, min(mu, abs(mu-L))/3])
    
    Returns: 
	- res : Value of the gaussian function (vessel radius) at the spatial point x
    """
    return A * np.exp(-((x - mu) ** 2) / (2 * sigma ** 2))

def gaussian_derivative(x, A, mu, sigma):
    """
    Derivative of the gaussian function which is used to define the vessel radius
    
    Parameters :
    - x: float/array : spatial points
    - A: float corresponding to the normalizing constant (= amplitude of the bump)
    - mu: location of the amplitude (in [0,L])
    - sigma: Standard deviation  (in ]0, min(mu, abs(mu-L))/3])
    
    Returns :
    - res : Value of the derivative at the spatial point x
    """
    return -A * (x - mu) / (sigma ** 2) * np.exp(-((x - mu) ** 2) / (2 * sigma ** 2))

if __name__ == '__main__':
	
	# Vessel parameters | Carotid bifurcation, parent vessel 

	L = 20.9						# Length of the vessel [cm]
	nx = 104						# Number of spatial points
	rho = 1.06						# Blood density [g/cm^3]
	mu = 3.5e-2						# Blood viscosity [g/(cm.s)] 				
	diastolic_pressure = 70			# Average diastolic pressure [mmHg]
	
	r_normal = 3.7e-1  				# Vessel radius at rest in a normal vessel [cm]
	A0_normal = np.pi * r_normal**2 # Cross sectionnal area at rest [cm²]

	print("Radius at rest : " + str(round(r_normal, 3)))
	print("Cross-sectional area at rest :"+ str(round(A0_normal, 3)))

	# Space and time discretisation

	dx = L /(nx-1) 					# Space step [cm]
	dt = 1e-5						# Time step [cm] (should be using CFL condition)
	T_final = 3						# Time of simulation [s]
	nt = ceil(T_final/dt)			# Number of time steps
	t = np.linspace(0,T_final, nt)  # Time discretisation 
	x = np.linspace(0, L, nx)		# Space discretisation

	# Setting anomalies in the vessel

	stenosis = False 				# Set to True if there is a stenosis in the vessel
	aneurysm = False				# Set to True if there is an aneurysm in the vessel

	x_start = 6						# Start of the anomaly 
	x_end = 12						# End of the anomaly
	index_start = ceil(x_start/dx)  # Index of the start of the anomaly
	index_end = ceil(x_end/dx)		# Index of the end of the anomaly
	normalized_vec = np.linspace(0,1, index_end-index_start) # This vector is created only for the bump since the arg must be in [0,1]
	x_anomaly = 0.50				# Location of the maximum point of the bump (in [0,1])
	x_width = 1 					# Width of the bump (in [0,L])
	a = 0.1*r_normal 				# Amplitude of the bump (in [0,r0], such a restriction is made to avoid r <=0 with stenosis)

	r = r_normal*np.ones_like(x)
	if aneurysm: 
		r = r_normal + gaussian_aneurysm(x, a, mu, 1)
		drdz = gaussian_derivative(x, a, mu, 1)
	elif stenosis:
		r = r_normal - gaussian_aneurysm(x, a, mu, 1)
		drdz = -gaussian_derivative(x, a, mu, 1)
	else:
		drdz = np.zeros_like(r)
	
	#r[index_start:index_end] = HicksHenneBump(normalized_vec, x_anomaly, x_width, a, r_normal, stenosis, aneurysm)
	#drdz = drdx(x, stenosis, aneurysm, x_anomaly, x_width, a, x_start, x_end) 
	
	A0 = np.pi*(r**2)

	# Parameters to estimate alpha empirically based on https://doi.org/10.1114/1.1326031

	k1 = 2.0e7	 					# Constant 1 [g/(s² cm)]
	k2 = -22.53 					# Constant 2 [cm^-1]
	k3 = 8.65e5 					# Constant 3 [g/(s² cm)]
	alpha = (k1*np.exp(k2*r) + k3)/(2*A0) # Elastance [g/(cm^3.s^2)]
	
	print("Elasticity at the inlet : " + str(round(alpha[0],2)))
	dalphadr = (k1*k2*np.exp(k2*r))/(2*A0) - (1/(A0*r))*(k1*np.exp(k2*r) + k3)
	
	# 3WK BC parameters

	R1 = 13900						# First resistance [g/s * cm^{-4}]
	R2 = 25300						# Second resistance [g/s * cm^{-4}]
	C = 1.3384e-6					# Capacitance coefficient [cm^4.s^2/g]

	# Get inlet as a function (:= Q_inlet)

	T, Q_inlet = get_data(sys.argv) # Inlet flow rate [cm^3/s] | Q_inlet Type : function
	

	# Plot parameters and variable used for visualisation

	plot_graphs = True				# Set to True if you want to see the graphs during the simulation
	time_interval = 1000 			# Number of time steps between each plot update 
	t_min_plot = 2*T 				# Minimum time to plot [s] (Start of second cycle)
	t_max_plot = 3*T 				# Maximum time to plot [s] (End of second cycle)
	index_min = int(t_min_plot/dt) 	# Index corresponding to t_min_plot
	index_max = int(t_max_plot/dt) 	# Index corresponding to t_max_plot
	index = 0 						# Index used to plot the graphs
	i=1

	time_plot = np.linspace(t_min_plot, t_max_plot, int((index_max-index_min)/time_interval) + 1) # Time array used for plotting
	Q_data = np.zeros((int(((index_max - index_min))/time_interval) +1, nx))
	A_data = np.zeros_like(Q_data)

	# Variables needed in LW 2 steps scheme (Speed + Pressure)
	
	A = A0.copy()
	Q = np.zeros_like(A) 

	A_half_m = np.zeros((nx)) 	    # A^n_{i-1/2}
	Q_half_m = np.zeros((nx))  		# Q^n_{i-1/2}

	A_half_p = np.zeros((nx))   	# A^n_{i+1/2}
	Q_half_p = np.zeros((nx))       # Q^n_{i+1/2}

	A0_half_m = 0.5*(A0[1:-1] + A0[0:-2])
	A0_half_p = 0.5*(A0[1:-1] + A0[2:]) 

	drdz_half_m = 0.5*(drdz[1:-1] + drdz[0:-2])
	drdz_half_p = 0.5*(drdz[1:-1] + drdz[2:])

	alpha_half_m = 0.5*(alpha[1:-1] + alpha[0:-2])
	alpha_half_p = 0.5*(alpha[1:-1] + alpha[2:])

	dalpha_half_m = 0.5*(dalphadr[1:-1] + dalphadr[0:-2])
	dalpha_half_p = 0.5*(dalphadr[1:-1] + dalphadr[2:])
	
	dtdx = dt/dx
	dtover2 = dt/2

	for n in tqdm(range(1,nt)): # tqdm is here to give an approximation of the time left, so we dont wait in front of the screen doing nothing :)
	
		# Inlet conditions 
		A[0], Q[0] = inlet_bc(Q_inlet, n, A, Q, dx, dt, mu, rho, alpha, dalphadr, T, drdz)

		
		# Outlet conditions
		A[-1], Q[-1] = WK_outlet_bc(R1, R2, C, Q, A, A0, dx, dt, mu, rho, alpha, dalphadr, diastolic_pressure, drdz, drdz_half_p, drdz_half_m)
		

		# Half time/space step 
		
		A_half_p = 0.5 * (A[2:] + A[1:-1]) - 0.5 * dtdx * (Q[2:] - Q[1:-1]) 
		A_half_m = 0.5 * (A[1:-1] + A[0:-2]) - 0.5 * dtdx * (Q[1:-1] - Q[0:-2]) 

		Q_half_p = 0.5 * (Q[2:] + Q[1:-1]) - 0.5* dtdx * (Flux(Q,A,A0,alpha,rho, j = 2) - Flux(Q,A,A0, alpha, rho, j = 1, k = -1)) \
			+ dtover2 * (Source(Q,A,A0, mu,rho, drdz,alpha, dalphadr, j = 2) + Source(Q,A,A0,mu,rho,drdz,alpha,dalphadr, j =1, k = -1))
		
		Q_half_m = 0.5 * (Q[1:-1] + Q[0:-2]) - 0.5* dtdx * (Flux(Q,A,A0,alpha,rho, j = 1, k = -1) - Flux(Q,A,A0, alpha, rho, j = 0, k = -2)) \
			+ dtover2 * (Source(Q,A,A0,mu,rho,drdz,alpha, dalphadr, j = 1, k = -1) + Source(Q,A,A0,mu,rho, drdz,alpha, dalphadr, j =0, k = -2))
		
		# Full step
		
		A[1:-1] = A[1:-1] - dtdx * (Q_half_p - Q_half_m)
		
		Q[1:-1] = Q[1:-1] - dtdx * (Flux(Q_half_p, A_half_p, A0_half_p, alpha_half_p, rho, j = 0)\
			    - Flux(Q_half_m, A_half_m, A0_half_m, alpha_half_m, rho, j = 0))\
				+ dtover2 * (Source(Q_half_p, A_half_p, A0_half_p , mu, rho,drdz_half_p, alpha_half_p,dalpha_half_p,j = 0) \
		 		+ Source(Q_half_m, A_half_m, A0_half_m, mu, rho,drdz_half_m,alpha_half_m,dalpha_half_m, j = 0)) 
		
		# Checking if the cfl condition is still satisfied 
		
		mean_u = np.mean(Q/A)
		mean_alpha = np.mean(alpha)

		# Checking if the CFL condition is satisfied
		CFL_condition(mean_u, A0_normal,  mean_alpha, rho, dx, dt, n, nt)

		if n % time_interval == 0:
			# Live plot (optional), it tends to slow down the simulation + window might superpose with other windows
			if plot_graphs:
				plt.figure(1, figsize=(10, 6))
				plt.clf()

				plt.subplot(4, 1, 1)
				plt.plot(x, A, 'b-', linewidth=1.5)
				plt.title(f'Cross-sectional Area (A) at t = {n * dt:.2f} s')
				plt.xlabel('Position (cm)')
				plt.ylabel('A (cm²)')
				plt.xlim([0, L])
				plt.ylim([0.8 * A0_normal, 1.5 * A0_normal])
				plt.grid(True)

				plt.subplot(4, 1, 2)
				plt.plot(x, Q, 'r-', linewidth=1.5)
				plt.title(f'Flow Rate (Q) at t = {n * dt:.2f} s')
				plt.xlabel('Position (cm)')
				plt.ylabel('Q (cm³/s)')
				plt.xlim([0, L])
				if len(sys.argv) == 2:
					plt.ylim([0, 30])
				else:
					plt.ylim([0, 5])
				plt.grid(True)

				plt.subplot(4, 1, 3)
				plt.plot(x, Q/A, 'b-', linewidth=1.5)
				plt.title(f'Velocity (U) at t = {n * dt:.2f} s')
				plt.xlabel('Position (cm)')
				plt.ylabel('U (cm/s)')
				plt.xlim([0, L])
				plt.ylim([0, 200])
				plt.grid(True)

				plt.subplot(4, 1, 4)
				plt.plot(x, alpha*(A-A0)/1333.22 + diastolic_pressure, 'r-', linewidth=1.5)
				plt.title(f'Transmural Pressure (P) at t = {n * dt:.2f} s')
				plt.xlabel('Position (cm)')
				plt.ylabel('P (mmHg)')
				plt.xlim([0, L])
				plt.ylim([20, 200])
				plt.grid(True)

				plt.pause(0.001)

		if n*dt >= t_min_plot and n*dt <= t_max_plot and n% time_interval == 0:
			# Save data for plotting
			A_data[index,:] = A
			Q_data[index,:] = Q
			index += 1
			
	# plot the results
	#plt.figure()
	#plt.plot(time_plot, Q_inlet(periodic(time_plot,T)))
	
	# Hard-coding to fix bug related to vizualisation for some time interval values where the last column isnt filled

	if sum(abs(A_data[-1, :])) == 0:
		A_data = A_data[:-1, :]
		Q_data = Q_data[:-1, :]
		time_plot = time_plot[:-1]
	else:
		pass

	P_data = (alpha * ((A_data) - A0))/1333.322  # Pressure in mmHg | 
	U_data = Q_data/A_data

	print(np.max(A_data[:,:]))
	print(np.max(P_data[:,:]))
	if plot_graphs:
		fig = plt.figure()
		ax = fig.add_subplot(111, projection='3d')
		X, Y = np.meshgrid(time_plot, x)
		surf = ax.plot_surface(X, Y, A_data.T, rstride=1, cstride=1, cmap=cm.viridis,
							linewidth=0, antialiased=False)
		ax.set_xlabel('t (s)')
		ax.set_ylabel('z (cm)')
		ax.set_zlabel('Cross sectionnal area (cm²)')
		ax.set_xlim([t_min_plot, t_max_plot])
		ax.set_ylim([min(x), max(x)])
		fig.colorbar(surf, shrink=0.5, aspect=5)

		fig3 = plt.figure()
		ax3 = fig3.add_subplot(111, projection='3d')
		surf3 = ax3.plot_surface(X, Y, U_data.T, rstride=1, cstride=1, cmap=cm.viridis,
							linewidth=0, antialiased=False)
		ax3.set_xlabel('t (s)')
		ax3.set_ylabel('z (cm)')
		ax3.set_zlabel('Velocity (cm/s)')
		ax3.set_xlim([t_min_plot, t_max_plot])
		ax3.set_ylim([min(x), max(x)])
		fig3.colorbar(surf3, shrink=0.5, aspect=5)

		fig2 = plt.figure()
		ax2 = fig2.add_subplot(111, projection='3d')
		surf2 = ax2.plot_surface(X, Y, Q_data.T, rstride=1, cstride=1, cmap=cm.viridis,
							linewidth=0, antialiased=False)
		ax2.set_xlabel('t (s)')
		ax2.set_ylabel('z (cm)')
		ax2.set_zlabel('Flow rate (cm^3/s)')
		ax2.set_xlim([t_min_plot, t_max_plot])
		ax2.set_ylim([min(x), max(x)])
		fig2.colorbar(surf2, shrink=0.5, aspect=5)

		fig_pressure = plt.figure()
		ax_pressure = fig_pressure.add_subplot(121)
		ax_pressure.plot(time_plot, diastolic_pressure + P_data.T[int(0.33*np.shape(P_data)[1]), :]) #approx 6cm
		ax_pressure.set_xlabel('t (s)')
		ax_pressure.set_ylabel('Pressure [mmHg]')
		ax_pressure2 = fig_pressure.add_subplot(122)
		ax_pressure2.plot(time_plot, diastolic_pressure + P_data.T[int(0.66*np.shape(P_data)[1]), :]) #approx 12CM
		ax_pressure2.set_xlabel('t (s)')
		ax_pressure2.set_ylabel('Pressure [mmHg]')
		plt.show()

	write_data(A_data, P_data, Q_data, x, time_plot)